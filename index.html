import { useState, useEffect, useRef, useCallback } from "react"; const SUITS = ["â™ ", "â™¥", "â™¦", "â™£"]; const RANKS = ["3","4","5","6","7","8","9","10","J","Q","K","A","2"]; const AVATARS = [{emoji:"ðŸ¦",bg:"bg-amber-600"},{emoji:"ðŸ‰",bg:"bg-red-600"},{emoji:"ðŸ¦…",bg:"bg-sky-600"},{emoji:"ðŸº",bg:"bg-slate-600"},{emoji:"ðŸ¦Š",bg:"bg-orange-500"}]; const RULES_LIST = [{id:"revolution",name:"é©å‘½",desc:"4æžšä»¥ä¸Šã§å¼·ã•é€†è»¢",def:true},{id:"eightCut",name:"8åˆ‡ã‚Š",desc:"8ã§å ´æµã‚Œ",def:true},{id:"elevenBack",name:"11ãƒãƒƒã‚¯",desc:"Jã§ä¸€æ™‚é€†è»¢",def:false},{id:"lock",name:"ç¸›ã‚Š",desc:"åŒã‚¹ãƒ¼ãƒˆç¸›ã‚Š",def:false},{id:"spade3",name:"ã‚¹ãƒš3",desc:"JOKERã«â™ 3",def:true},{id:"noJokerFinish",name:"Jç¦",desc:"JOKERä¸ŠãŒã‚Šç¦æ­¢",def:true}]; const AI_LEVELS = [{id:"easy",name:"å¼±ã„",bg:"bg-green-600"},{id:"normal",name:"æ™®é€š",bg:"bg-yellow-600"},{id:"hard",name:"å¼·ã„",bg:"bg-red-600"}]; const useSound = () => { const ctxRef = useRef(null); const getCtx = () => { if (!ctxRef.current) ctxRef.current = new (window.AudioContext || window.webkitAudioContext)(); return ctxRef.current; }; const play = (freq, dur, type, vol, delay) => { try { const ctx = getCtx(); const osc = ctx.createOscillator(); const gain = ctx.createGain(); osc.type = type || "sine"; osc.frequency.value = freq; const startTime = ctx.currentTime + (delay || 0); gain.gain.setValueAtTime(0, startTime); gain.gain.linearRampToValueAtTime(vol || 0.3, startTime + 0.01); gain.gain.exponentialRampToValueAtTime(0.01, startTime + dur); osc.connect(gain); gain.connect(ctx.destination); osc.start(startTime); osc.stop(startTime + dur); } catch (e) {} }; const playChord = (freqs, dur, type, vol, delay) => { freqs.forEach(f => play(f, dur, type, vol / freqs.length, delay)); }; return { // ã‚«ãƒ¼ãƒ‰é¸æŠž - ã‚­ãƒ©ãƒƒã¨ã—ãŸéŸ³ cardSelect: () => { play(1200, 0.08, "sine", 0.15); play(1800, 0.06, "sine", 0.1, 0.02); }, // ã‚«ãƒ¼ãƒ‰ã‚’å‡ºã™ - ãƒ‘ã‚·ãƒƒã¨ã„ã†éŸ³ cardPlay: () => { play(200, 0.05, "square", 0.2); play(800, 0.08, "sine", 0.15, 0.02); play(1200, 0.1, "triangle", 0.1, 0.05); }, // ãƒ‘ã‚¹ - ä¸‹ãŒã‚‹éŸ³ pass: () => { play(400, 0.15, "sine", 0.15); play(300, 0.15, "sine", 0.12, 0.08); play(200, 0.2, "sine", 0.1, 0.15); }, // é©å‘½ - ãƒ‰ãƒ©ãƒžãƒãƒƒã‚¯ãªé€†è»¢éŸ³ revolution: () => { // ä½ŽéŸ³ã®ãƒ‰ãƒ©ãƒ  play(80, 0.3, "sine", 0.4); play(60, 0.4, "sine", 0.3, 0.1); // ä¸Šæ˜‡ã™ã‚‹ã‚¢ãƒ«ãƒšã‚¸ã‚ª [330, 440, 554, 659, 880, 1047, 1319].forEach((f, i) => { play(f, 0.25, "sawtooth", 0.15, i * 0.06); }); // æœ€å¾Œã®ã‚¤ãƒ³ãƒ‘ã‚¯ãƒˆ setTimeout(() => { playChord([523, 659, 784, 1047], 0.5, "sine", 0.4); }, 450); }, // 8åˆ‡ã‚Š - ã‚·ãƒ£ã‚­ãƒ¼ãƒ³ã¨ã„ã†éŸ³ eightCut: () => { play(2000, 0.15, "sawtooth", 0.2); play(2500, 0.1, "square", 0.15, 0.03); play(3000, 0.08, "sine", 0.2, 0.08); play(1500, 0.2, "triangle", 0.15, 0.12); }, // ã‚¤ãƒ¬ãƒ–ãƒ³ãƒãƒƒã‚¯ - åè»¢éŸ³ elevenBack: () => { [880, 660, 440, 330, 440, 660, 880].forEach((f, i) => { play(f, 0.12, "triangle", 0.15, i * 0.05); }); }, // å¤§å¯Œè±ª - è±ªè¯ãªãƒ•ã‚¡ãƒ³ãƒ•ã‚¡ãƒ¼ãƒ¬ daifugo: () => { // ãƒ•ã‚¡ãƒ³ãƒ•ã‚¡ãƒ¼ãƒ¬ const melody = [523, 659, 784, 1047, 784, 1047, 1319]; melody.forEach((f, i) => { play(f, i === melody.length - 1 ? 0.6 : 0.2, "sine", 0.25, i * 0.15); }); // ãƒãƒ¼ãƒ¢ãƒ‹ãƒ¼ setTimeout(() => { playChord([523, 659, 784, 1047], 0.8, "sine", 0.3); }, melody.length * 0.15 * 1000); // ã‚­ãƒ©ã‚­ãƒ© [2000, 2400, 2800, 3200].forEach((f, i) => { play(f, 0.1, "sine", 0.08, 0.8 + i * 0.1); }); }, // å¯Œè±ª - çŸ­ã„ãƒ•ã‚¡ãƒ³ãƒ•ã‚¡ãƒ¼ãƒ¬ fugo: () => { [440, 554, 659, 880].forEach((f, i) => { play(f, i === 3 ? 0.4 : 0.15, "sine", 0.2, i * 0.1); }); playChord([440, 554, 659], 0.5, "triangle", 0.15, 0.4); }, // å¹³æ°‘ heimin: () => { play(440, 0.2, "sine", 0.15); play(440, 0.3, "triangle", 0.1, 0.1); }, // è²§æ°‘ hinmin: () => { play(330, 0.2, "sine", 0.15); play(294, 0.3, "sine", 0.12, 0.1); }, // å¤§è²§æ°‘ daihinmin: () => { play(220, 0.3, "sine", 0.15); play(165, 0.4, "sine", 0.12, 0.15); play(110, 0.5, "sine", 0.1, 0.3); }, // ã‚²ãƒ¼ãƒ é–‹å§‹ - è¯ã‚„ã‹ãªé–‹å§‹éŸ³ gameStart: () => { // ãƒ‰ãƒ©ãƒ ãƒ­ãƒ¼ãƒ«é¢¨ for (let i = 0; i < 8; i++) { play(100 + i * 10, 0.08, "square", 0.1, i * 0.05); } // ãƒ¡ãƒ­ãƒ‡ã‚£ [392, 523, 659, 784, 1047].forEach((f, i) => { play(f, i === 4 ? 0.5 : 0.2, "sine", 0.2, 0.4 + i * 0.12); }); // æœ€å¾Œã®ã‚³ãƒ¼ãƒ‰ setTimeout(() => { playChord([523, 659, 784, 1047], 0.6, "sine", 0.3); }, 1000); }, // CPUè¿½åŠ  - ãƒãƒƒãƒ—ãªéŸ³ join: () => { play(523, 0.1, "sine", 0.2); play(784, 0.1, "sine", 0.2, 0.08); play(1047, 0.15, "sine", 0.15, 0.15); }, // ãƒ–ã‚¶ãƒ¼ - ä¸æ­£è§£éŸ³ buzzer: () => { playChord([200, 250], 0.15, "sawtooth", 0.25); playChord([180, 220], 0.2, "sawtooth", 0.2, 0.12); }, // ã‚¢ãƒã‚¿ãƒ¼é¸æŠž - ã‚­ãƒ©ãƒƒã¨ã—ãŸéŸ³ avatarSelect: () => { play(880, 0.1, "sine", 0.15); play(1320, 0.12, "sine", 0.12, 0.05); play(1760, 0.08, "sine", 0.1, 0.1); }, // ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯ click: () => { play(600, 0.06, "sine", 0.1); play(900, 0.04, "sine", 0.08, 0.02); } }; }; const createDeck = () => { const d = []; RANKS.forEach((r, i) => SUITS.forEach(s => d.push({ suit: s, rank: r, value: i }))); d.push({ suit: "joker", rank: "JOKER", value: 99 }); d.push({ suit: "joker", rank: "JOKER", value: 99 }); return d.map((c, i) => ({ ...c, id: c.suit + "-" + c.rank + "-" + i })); }; const shuffle = a => { const b = [...a]; for (let i = b.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [b[i], b[j]] = [b[j], b[i]]; } return b; }; const sortCards = c => [...c].sort((a, b) => { if (a.rank === "JOKER") return 1; if (b.rank === "JOKER") return -1; return a.value - b.value || SUITS.indexOf(a.suit) - SUITS.indexOf(b.suit); }); const getCardSetValue = cards => { const nj = cards.filter(c => c.rank !== "JOKER"); return nj.length === 0 ? 99 : nj[0].value; }; const isValidPlay = (s, f, r, ru, ls) => { if (!s.length) return false; const nj = s.filter(c => c.rank !== "JOKER"); if (nj.length > 0 && new Set(nj.map(c => c.rank)).size > 1) return false; if (!f.length) return true; if (s.length !== f.length) return false; if (ru.spade3 && f.length === 1 && s.length === 1 && f[0].rank === "JOKER" && s[0].suit === "â™ " && s[0].rank === "3") return true; if (ru.lock && ls && nj.length > 0 && !nj.every(c => c.suit === ls)) return false; const sv = getCardSetValue(s); const fv = getCardSetValue(f); if (sv === 99 && fv !== 99) return true; if (fv === 99) return false; return r ? sv < fv : sv > fv; }; const Card = ({ card, selected, onClick, disabled, small }) => { const red = card.suit === "â™¥" || card.suit === "â™¦"; const jk = card.rank === "JOKER"; const sz = small ? "w-10 h-14" : "w-12 h-16"; return (
{jk ? (
ðŸƒ JOKER
) : (
{card.rank}
{card.suit}
)}
); }; const Avatar = ({ player, size }) => { const sz = { sm: "w-7 h-7 text-base", md: "w-10 h-10 text-xl", lg: "w-14 h-14 text-2xl" }; const a = AVATARS[player.avatar] || AVATARS[0]; return (
{player.customAvatar ?  : a.emoji}
); }; export default function DaifugoOnline() { const [screen, setScreen] = useState("title"); const [username, setUsername] = useState(""); const [avatar, setAvatar] = useState(0); const [customAvatar, setCustomAvatar] = useState(null); const [soundOn, setSoundOn] = useState(true); const [rankings, setRankings] = useState([]); const [usernameError, setUsernameError] = useState(""); const [roomPlayers, setRoomPlayers] = useState([]); const [selectedRules, setSelectedRules] = useState(RULES_LIST.filter(r => r.def).map(r => r.id)); const [roomLogs, setRoomLogs] = useState([]); const [isSolo, setIsSolo] = useState(false); const [startOrderRule, setStartOrderRule] = useState("diamond3"); const [showRoulette, setShowRoulette] = useState(false); const [rouletteWinner, setRouletteWinner] = useState(null); const [hands, setHands] = useState({}); const [field, setField] = useState([]); const [current, setCurrent] = useState(0); const [selected, setSelected] = useState([]); const [passCount, setPassCount] = useState(0); const [isRev, setIsRev] = useState(false); const [tempRev, setTempRev] = useState(false); const [lockSuit, setLockSuit] = useState(null); const [logs, setLogs] = useState([]); const [finishOrder, setFinishOrder] = useState([]); const [gameOver, setGameOver] = useState(false); const [effect, setEffect] = useState(null); const fileInputRef = useRef(null); const sound = useSound(); const rules = { revolution: selectedRules.includes("revolution"), eightCut: selectedRules.includes("eightCut"), elevenBack: selectedRules.includes("elevenBack"), lock: selectedRules.includes("lock"), spade3: selectedRules.includes("spade3"), noJokerFinish: selectedRules.includes("noJokerFinish") }; const goldStyle = { color: "#d4af37", fontFamily: "serif" }; const boxStyle = { border: "2px solid #4a7c5c", background: "linear-gradient(145deg,rgba(45,90,61,0.9),rgba(26,61,42,0.95))" }; useEffect(() => { const load = async () => { try { const r = await window.storage.get("daifugo-profile"); if (r && r.value) { const p = JSON.parse(r.value); if (p.username) setUsername(p.username); if (typeof p.avatar === "number") setAvatar(p.avatar); if (p.customAvatar) setCustomAvatar(p.customAvatar); } } catch (e) {} try { const r = await window.storage.get("daifugo-rankings", true); if (r && r.value) setRankings(JSON.parse(r.value)); } catch (e) {} }; load(); }, []); const saveProfile = async (n, a, c) => { try { await window.storage.set("daifugo-profile", JSON.stringify({ username: n, avatar: a, customAvatar: c })); } catch (e) {} }; const saveRankings = async (r) => { setRankings(r); try { await window.storage.set("daifugo-rankings", JSON.stringify(r), true); } catch (e) {} }; const handleUsernameChange = (n) => { setUsername(n); setUsernameError(""); if (n.trim()) saveProfile(n, avatar, customAvatar); }; const handleAvatarChange = (a) => { setAvatar(a); setCustomAvatar(null); saveProfile(username, a, null); if (soundOn) sound.avatarSelect(); }; const handleFileUpload = (e) => { const f = e.target.files && e.target.files[0]; if (f) { const r = new FileReader(); r.onloadend = () => { setCustomAvatar(r.result); saveProfile(username, avatar, r.result); if (soundOn) sound.avatarSelect(); }; r.readAsDataURL(f); } }; const checkUsername = (n) => { if (!n.trim()) { setUsernameError("åå‰ã‚’å…¥åŠ›"); return false; } if (n.length > 12) { setUsernameError("12æ–‡å­—ä»¥å†…"); return false; } setUsernameError(""); return true; }; const addRoomLog = (m) => setRoomLogs(p => [...p.slice(-20), { id: Date.now(), text: m }]); const addLog = (m) => setLogs(p => [...p.slice(-30), { id: Date.now() + Math.random(), text: m }]); const showEffect = (t, e) => { setEffect({ type: t, ...e }); if (soundOn) { if (sound[t]) sound[t](); else if (t === "lock") sound.click(); } }; const clearEffect = useCallback(() => setEffect(null), []); const addAI = (lv) => { if (roomPlayers.length >= 5) return; const names = ["CPU Î±", "CPU Î²", "CPU Î³", "CPU Î´"]; const cnt = roomPlayers.filter(p => p.isAI).length; const used = roomPlayers.map(p => p.avatar); const avail = AVATARS.map((_, i) => i).filter(i => !used.includes(i)); if (!avail.length) return; const av = avail[Math.floor(Math.random() * avail.length)]; setRoomPlayers(p => [...p, { id: "ai-" + Date.now(), name: names[cnt] || "CPU", avatar: av, isAI: true, aiLevel: lv || "normal", isReady: true }]); addRoomLog("ðŸ¤– CPUè¿½åŠ "); if (soundOn) sound.join(); }; const removePlayer = (id) => setRoomPlayers(ps => ps.filter(pl => pl.id !== id)); const toggleReady = () => setRoomPlayers(ps => ps.map(p => p.isHost ? { ...p, isReady: !p.isReady } : p)); const startSetup = (solo) => { if (!checkUsername(username)) return; saveProfile(username, avatar, customAvatar); setRoomPlayers([{ id: "player-" + Date.now(), name: username, avatar, customAvatar, isAI: false, isHost: true, isReady: false }]); setIsSolo(solo); setRoomLogs([]); addRoomLog("ðŸ‘‹ " + username + " ãŒãƒ«ãƒ¼ãƒ ä½œæˆ"); setScreen("room"); }; const canStartGame = () => roomPlayers.length >= 2 && roomPlayers.filter(p => !p.isAI).every(p => p.isReady); const startGame = () => { if (!canStartGame()) return; if (!isSolo && startOrderRule === "roulette") { setShowRoulette(true); setRouletteWinner(null); if (soundOn) sound.gameStart(); setTimeout(() => { const winner = Math.floor(Math.random() * roomPlayers.length); setRouletteWinner(winner); if (soundOn) sound.daifugo(); }, 2500); } else { startGameWithOrder(null); } }; const startGameWithOrder = (forcedFirst) => { const deck = shuffle(createDeck()); const newH = {}; roomPlayers.forEach(p => { newH[p.id] = []; }); deck.forEach((c, i) => newH[roomPlayers[i % roomPlayers.length].id].push(c)); Object.keys(newH).forEach(id => { newH[id] = sortCards(newH[id]); }); let first = forcedFirst !== null ? forcedFirst : 0; if (forcedFirst === null) { for (let i = 0; i < roomPlayers.length; i++) { if (newH[roomPlayers[i].id] && newH[roomPlayers[i].id].some(c => c.suit === "â™¦" && c.rank === "3")) { first = i; break; } } } setHands(newH); setField([]); setCurrent(first); setSelected([]); setPassCount(0); setIsRev(false); setTempRev(false); setLockSuit(null); setFinishOrder([]); setGameOver(false); setLogs([]); setShowRoulette(false); setRouletteWinner(null); showEffect("gameStart", {}); setTimeout(() => { setScreen("game"); addLog("ðŸŽ® " + roomPlayers[first].name + "ã‹ã‚‰é–‹å§‹"); }, 2500); }; const confirmRouletteStart = () => { if (rouletteWinner !== null) { startGameWithOrder(rouletteWinner); } }; const leaveGame = () => { setScreen("title"); setRoomPlayers([]); setGameOver(false); setIsSolo(false); setEffect(null); setShowRoulette(false); setRouletteWinner(null); }; const getCurrentRev = () => isRev !== tempRev; const handleSelect = (c) => { if (gameOver) return; if (roomPlayers[current] && roomPlayers[current].isAI) return; const me = roomPlayers.find(p => !p.isAI); if (!me || roomPlayers[current].id !== me.id) return; if (soundOn) sound.cardSelect(); setSelected(p => p.find(x => x.id === c.id) ? p.filter(x => x.id !== c.id) : [...p, c]); }; const nextTurn = (h, ps, c) => { let n = (c + 1) % ps.length; let t = 0; while (h[ps[n].id] && h[ps[n].id].length === 0 && t < ps.length) { n = (n + 1) % ps.length; t++; } setTempRev(false); setCurrent(n); }; const getRankTitle = (i, t) => { if (i === 0) return { type: "daifugo", title: "å¤§å¯Œè±ª" }; if (i === 1 && t >= 4) return { type: "fugo", title: "å¯Œè±ª" }; if (i === t - 1) return { type: "daihinmin", title: "å¤§è²§æ°‘" }; if (i === t - 2 && t >= 4) return { type: "hinmin", title: "è²§æ°‘" }; return { type: "heimin", title: "å¹³æ°‘" }; }; const handleFinish = async (p, newH) => { const newO = [...finishOrder, p]; setFinishOrder(newO); const rank = getRankTitle(newO.length - 1, roomPlayers.length); showEffect(rank.type, { player: p.name }); addLog("ðŸ† " + p.name + "ãŒ" + rank.title + "ï¼"); if (rank.type === "daifugo" && !p.isAI && !isSolo) { const ex = rankings.find(r => r.name === p.name); let nr; if (ex) { nr = rankings.map(r => r.name === p.name ? { ...r, wins: r.wins + 1 } : r); } else { nr = [...rankings, { name: p.name, avatar: p.avatar, wins: 1 }]; } nr.sort((a, b) => b.wins - a.wins); await saveRankings(nr); } const rem = roomPlayers.filter(pl => newH[pl.id] && newH[pl.id].length > 0); if (rem.length <= 1) { if (rem.length === 1) { setTimeout(() => { const lr = getRankTitle(newO.length, roomPlayers.length); showEffect(lr.type, { player: rem[0].name }); }, 2600); } setTimeout(() => setGameOver(true), rem.length === 1 ? 5200 : 2600); return; } nextTurn(newH, roomPlayers, current); }; const playCards = () => { if (soundOn) sound.cardPlay(); const p = roomPlayers[current]; const newH = { ...hands }; newH[p.id] = newH[p.id].filter(c => !selected.find(s => s.id === c.id)); if (rules.noJokerFinish && newH[p.id].length === 0 && selected.some(c => c.rank === "JOKER")) { addLog("âš ï¸ JOKERä¸ŠãŒã‚Šç¦æ­¢ï¼"); return; } if (rules.revolution && selected.length >= 4) { setIsRev(!isRev); showEffect("revolution", {}); addLog("ðŸ”„ " + p.name + "ãŒé©å‘½ï¼"); } if (rules.lock && field.length > 0) { const fs = field.filter(c => c.rank !== "JOKER").map(c => c.suit); const ss = selected.filter(c => c.rank !== "JOKER").map(c => c.suit); if (fs.length && ss.length && new Set(fs).size === 1 && new Set(ss).size === 1 && fs[0] === ss[0]) { setLockSuit(fs[0]); addLog("ðŸ”’ " + fs[0] + "ç¸›ã‚Šï¼"); } } addLog(p.name + ": " + selected.map(c => c.rank === "JOKER" ? "ðŸƒ" : c.suit + c.rank).join(" ")); if (rules.eightCut && selected.some(c => c.rank === "8")) { showEffect("eightCut", {}); addLog("8ï¸âƒ£ 8åˆ‡ã‚Šï¼"); setField([]); setHands(newH); setSelected([]); setPassCount(0); setLockSuit(null); setTempRev(false); if (newH[p.id].length === 0) handleFinish(p, newH); return; } if (rules.elevenBack && selected.some(c => c.rank === "J")) { setTempRev(true); if (soundOn) sound.elevenBack(); addLog("ðŸ”ƒ ã‚¤ãƒ¬ãƒ–ãƒ³ãƒãƒƒã‚¯ï¼"); } setField(selected); setHands(newH); setSelected([]); setPassCount(0); if (newH[p.id].length === 0) { handleFinish(p, newH); return; } nextTurn(newH, roomPlayers, current); }; const tryPlayCards = () => { if (!isValidPlay(selected, field, getCurrentRev(), rules, lockSuit)) { if (soundOn && selected.length > 0) sound.buzzer(); return; } playCards(); }; const pass = () => { if (soundOn) sound.pass(); const p = roomPlayers[current]; addLog(p.name + ": ãƒ‘ã‚¹"); const np = passCount + 1; setPassCount(np); const active = roomPlayers.filter(pl => hands[pl.id] && hands[pl.id].length > 0); if (np >= active.length - 1) { setField([]); setPassCount(0); setLockSuit(null); setTempRev(false); addLog("ðŸ’¨ å ´æµã‚Œ"); } nextTurn(hands, roomPlayers, current); }; // AI useEffect(() => { if (screen !== "game" || gameOver) return; const p = roomPlayers[current]; if (!p || !p.isAI) return; const t = setTimeout(() => { const hand = hands[p.id]; if (!hand || !hand.length) return; const currRev = getCurrentRev(); const groups = {}; const jokers = []; hand.forEach(c => { if (c.rank === "JOKER") jokers.push(c); else { if (!groups[c.rank]) groups[c.rank] = []; groups[c.rank].push(c); } }); let play = null; const diff = p.aiLevel === "hard" ? 0.95 : p.aiLevel === "easy" ? 0.5 : 0.75; if (field.length === 0) { const sorted = Object.values(groups).sort((a, b) => a[0].value - b[0].value); if (sorted.length > 0) play = currRev ? sorted[sorted.length - 1] : sorted[0]; else if (jokers.length > 0) play = [jokers[0]]; } else { const cands = []; const need = field.length; for (const cards of Object.values(groups)) { if (cards.length >= need && isValidPlay(cards.slice(0, need), field, currRev, rules, lockSuit)) { cands.push(cards.slice(0, need)); } if (cards.length + jokers.length >= need && cards.length < need) { const pl = [...cards, ...jokers.slice(0, need - cards.length)]; if (isValidPlay(pl, field, currRev, rules, lockSuit)) cands.push(pl); } } if (need === 1 && jokers.length > 0 && isValidPlay([jokers[0]], field, currRev, rules, lockSuit)) { cands.push([jokers[0]]); } if (cands.length && Math.random() < diff) { cands.sort((a, b) => { const av = getCardSetValue(a); const bv = getCardSetValue(b); return currRev ? bv - av : av - bv; }); play = cands[0]; } } if (play && play.length) { const newH = { ...hands }; newH[p.id] = newH[p.id].filter(c => !play.find(s => s.id === c.id)); if (rules.revolution && play.length >= 4) { setIsRev(prev => !prev); showEffect("revolution", {}); addLog("ðŸ”„ " + p.name + "ãŒé©å‘½ï¼"); } addLog(p.name + ": " + play.map(c => c.rank === "JOKER" ? "ðŸƒ" : c.suit + c.rank).join(" ")); if (rules.eightCut && play.some(c => c.rank === "8")) { showEffect("eightCut", {}); addLog("8ï¸âƒ£ 8åˆ‡ã‚Šï¼"); setField([]); setHands(newH); setPassCount(0); setLockSuit(null); setTempRev(false); if (newH[p.id].length === 0) handleFinish(p, newH); return; } if (rules.elevenBack && play.some(c => c.rank === "J")) { setTempRev(true); if (soundOn) sound.elevenBack(); addLog("ðŸ”ƒ ã‚¤ãƒ¬ãƒ–ãƒ³ãƒãƒƒã‚¯ï¼"); } setField(play); setHands(newH); setPassCount(0); if (newH[p.id].length === 0) { handleFinish(p, newH); return; } nextTurn(newH, roomPlayers, current); } else { addLog(p.name + ": ãƒ‘ã‚¹"); const np = passCount + 1; setPassCount(np); const active = roomPlayers.filter(pl => hands[pl.id] && hands[pl.id].length > 0); if (np >= active.length - 1) { setField([]); setPassCount(0); setLockSuit(null); setTempRev(false); addLog("ðŸ’¨ å ´æµã‚Œ"); } nextTurn(hands, roomPlayers, current); } }, 1400); return () => clearTimeout(t); }, [current, screen, gameOver, hands]); // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¿ã‚¤ãƒžãƒ¼ useEffect(() => { if (!effect) return; const t = setTimeout(clearEffect, 2500); return () => clearTimeout(t); }, [effect, clearEffect]); // ãƒ«ãƒ¼ãƒ¬ãƒƒãƒˆãƒ¢ãƒ¼ãƒ€ãƒ« const renderRoulette = () => { if (!showRoulette) return null; const displayPlayer = rouletteWinner !== null ? roomPlayers[rouletteWinner] : roomPlayers[Math.floor(Date.now() / 100) % roomPlayers.length]; return (
ðŸŽ° é †ç•ªæŠ½é¸
{displayPlayer?.customAvatar ?  : (AVATARS[displayPlayer?.avatar]?.emoji || "ðŸ‘¤")}
{displayPlayer?.name}
{rouletteWinner === null ? (
æŠ½é¸ä¸­...
) : (
ðŸŽ‰ {roomPlayers[rouletteWinner].name} ãŒæœ€åˆï¼
â–¶ ã‚²ãƒ¼ãƒ é–‹å§‹
)}
); }; // ãƒ«ãƒ¼ãƒ¬ãƒƒãƒˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ const [, forceUpdate] = useState(0); useEffect(() => { if (showRoulette && rouletteWinner === null) { const interval = setInterval(() => forceUpdate(n => n + 1), 100); return () => clearInterval(interval); } }, [showRoulette, rouletteWinner]); // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆæç”» const renderEffect = () => { if (!effect) return null; const data = { revolution: { title: "é©å‘½ç™ºå‹•", sub: "å¼·ã•ãŒé€†è»¢ï¼", colors: ["#ff0000", "#ff6600", "#ffcc00"] }, eightCut: { title: "ï¼˜åˆ‡ã‚Š", sub: "å ´ãŒæµã‚ŒãŸï¼", colors: ["#00ffff", "#0088ff", "#0044ff"] }, elevenBack: { title: "ã‚¤ãƒ¬ãƒ–ãƒ³ãƒãƒƒã‚¯", sub: "ä¸€æ™‚é€†è»¢ï¼", colors: ["#ff00ff", "#aa00ff", "#6600ff"] }, daifugo: { title: "å¤§å¯Œè±ª", sub: "", colors: ["#ffd700", "#ffaa00", "#ff8800"] }, fugo: { title: "å¯Œè±ª", sub: "", colors: ["#c0c0c0", "#e0e0e0", "#ffffff"] }, heimin: { title: "å¹³æ°‘", sub: "", colors: ["#44cc44", "#66ee66", "#88ff88"] }, hinmin: { title: "è²§æ°‘", sub: "", colors: ["#4488ff", "#66aaff", "#88ccff"] }, daihinmin: { title: "å¤§è²§æ°‘", sub: "", colors: ["#666666", "#888888", "#aaaaaa"] }, gameStart: { title: "GAME START", sub: "å‹åˆ©ã‚’æŽ´ã‚ï¼", colors: ["#00ff88", "#00ffaa", "#00ffcc"] } }; const e = data[effect.type] || data.gameStart; const sub = effect.player ? "â€• " + effect.player + " â€•" : e.sub ? "â€• " + e.sub + " â€•" : ""; return (
{e.title}
{sub &&
{sub}
}
); }; // ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ if (screen === "title") { return (
å¤§å¯Œè±ª
ONLINE

fileInputRef.current && fileInputRef.current.click()} className="relative cursor-pointer">
{customAvatar ?  : AVATARS[avatar].emoji}
é¸æŠžã•ã‚Œã¦ã„ã¾ã›ã‚“
{AVATARS.map((a, i) => ( handleAvatarChange(i)} className="w-12 h-12 rounded-full text-2xl flex items-center justify-center" style={{ background: avatar === i && !customAvatar ? "linear-gradient(145deg,#ffd700,#b8860b)" : "linear-gradient(145deg,#2d5a3d,#1a3d2a)", border: "2px solid " + (avatar === i && !customAvatar ? "#ffd700" : "#4a7c5c") }}>{a.emoji} ))}
{username}
 handleUsernameChange(e.target.value)} placeholder="ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒãƒ¼ãƒ " maxLength={12} className="w-full px-4 py-3 rounded-lg text-center text-lg" style={{ background: "linear-gradient(145deg,rgba(45,90,61,0.8),rgba(26,61,42,0.9))", border: "2px solid #4a7c5c", color: "#e8dcc4" }} /> {usernameError &&
{usernameError}

}
startSetup(true)} disabled={!username.trim()} className="w-full py-4 rounded-xl font-bold text-lg disabled:opacity-40" style={{ ...boxStyle, color: "#d4af37" }}>ä¸€äººã§ãƒ—ãƒ¬ã‚¤ startSetup(false)} disabled={!username.trim()} className="w-full py-4 rounded-xl font-bold text-lg disabled:opacity-40" style={{ ...boxStyle, color: "#d4af37" }}>ãƒžãƒ«ãƒãƒ—ãƒ¬ã‚¤ setScreen("ranking")} className="w-full py-4 rounded-xl font-bold text-lg" style={{ ...boxStyle, color: "#d4af37" }}>ãƒ©ãƒ³ã‚­ãƒ³ã‚°
setSoundOn(!soundOn)} className="flex items-center gap-2" style={goldStyle}> {soundOn ? "ðŸ”Š" : "ðŸ”‡"} åŠ¹æžœéŸ³ {soundOn ? "ON" : "OFF"}
); } // ãƒ©ãƒ³ã‚­ãƒ³ã‚°ç”»é¢ if (screen === "ranking") { return (
setScreen("title")} className="px-3 py-1 rounded-lg text-sm" style={{ ...goldStyle, border: "1px solid #6b9b7a" }}>â† æˆ»ã‚‹
ðŸ† ãƒ©ãƒ³ã‚­ãƒ³ã‚°
{rankings.length === 0 ?
ã¾ã ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“
: rankings.slice(0, 20).map((r, i) => (
{i === 0 ? "ðŸ‘‘" : i === 1 ? "ðŸ¥ˆ" : i === 2 ? "ðŸ¥‰" : i + 1}
{AVATARS[r.avatar] ? AVATARS[r.avatar].emoji : "ðŸ‘¤"}
{r.name}
{r.wins}å›ž
))}
); } // ãƒ«ãƒ¼ãƒ ç”»é¢ if (screen === "room") { const me = roomPlayers.find(p => p.isHost); return (
{renderRoulette()}
é€€å‡º
{isSolo ? "ðŸŽ® ã‚½ãƒ­" : "ðŸ‘¥ ãƒžãƒ«ãƒ"}
å‚åŠ è€… ({roomPlayers.length}/5)
{roomPlayers.map(p => (
{p.name}
{p.isAI && {AI_LEVELS.find(l => l.id === p.aiLevel)?.name}} {p.isHost && ðŸ‘‘}
{p.isReady && âœ“} {p.isAI && removePlayer(p.id)} className="text-red-400">âœ•}
))}
{roomPlayers.length < 5 && (
CPUè¿½åŠ : {AI_LEVELS.map(lv => addAI(lv.id)} className={"px-3 py-1 rounded text-xs font-bold text-white " + lv.bg}>{lv.name})}
)}
ãƒ«ãƒ¼ãƒ«è¨­å®š
{RULES_LIST.map(rule => (
 setSelectedRules(p => e.target.checked ? [...p, rule.id] : p.filter(r => r !== rule.id))} className="w-3 h-3 accent-yellow-500" /> {rule.name}
{rule.desc}
))}
{!isSolo && (
é †ç•ªã®æ±ºã‚æ–¹
{ setStartOrderRule("diamond3"); if (soundOn) sound.click(); }}>  setStartOrderRule("diamond3")} className="accent-yellow-500" />
â™¦ï¸ â™¦3ã‚’æŒã¤äººã‹ã‚‰
ä¼çµ±çš„ãªãƒ«ãƒ¼ãƒ«
{ setStartOrderRule("roulette"); if (soundOn) sound.click(); }}>  setStartOrderRule("roulette")} className="accent-yellow-500" />
ðŸŽ° ãƒ«ãƒ¼ãƒ¬ãƒƒãƒˆ
ãƒ©ãƒ³ãƒ€ãƒ æŠ½é¸
)}
{me && me.isReady ? "æº–å‚™è§£é™¤" : "æº–å‚™å®Œäº†"} é–‹å§‹
); } // ã‚²ãƒ¼ãƒ ç”»é¢ if (screen === "game") { const me = roomPlayers.find(p => !p.isAI); const myHand = me && hands[me.id] ? hands[me.id] : []; const currentPlayer = roomPlayers[current]; const isMyTurn = currentPlayer && me && currentPlayer.id === me.id; const currRev = getCurrentRev(); return (
{renderEffect()} {gameOver && (
ðŸ†
ã‚²ãƒ¼ãƒ çµ‚äº†
{finishOrder.map((p, i) => { const rank = getRankTitle(i, roomPlayers.length); return (
{i === 0 ? "ðŸ‘‘" : i + 1}
{p.name}
{rank.title}
); })}
ðŸ  ã‚¿ã‚¤ãƒˆãƒ«ã¸
)}
{currRev && ðŸ”„é©å‘½ä¸­} {lockSuit && ðŸ”’{lockSuit}ç¸›ã‚Š}
é€€å‡º
ðŸ“‹ãƒ«ãƒ¼ãƒ«: {rules.revolution && é©å‘½} {rules.eightCut && 8åˆ‡} {rules.elevenBack && 11B} {rules.lock && ç¸›} {rules.spade3 && â™ 3} {rules.noJokerFinish && Jç¦}
{roomPlayers.map((p, i) => { const cnt = hands[p.id] ? hands[p.id].length : 0; const isCurr = i === current; const fin = finishOrder.includes(p); return (
{p.name}
{fin ? "âœ“" : cnt + "æžš"}
{isCurr &&
â—
}
); })}
{field.length > 0 ?
{field.map(c => )}
: ã‚«ãƒ¼ãƒ‰ã‚’å‡ºã—ã¦ãã ã•ã„}
æ‰‹æœ­ ({myHand.length}æžš)
{myHand.map(c => s.id === c.id)} onClick={() => handleSelect(c)} disabled={!isMyTurn} />)}
{isMyTurn && (
å‡ºã™ ãƒ‘ã‚¹
)}
ãƒ­ã‚°
{logs.slice(-4).map(log =>
{log.text}
)}
); } return null; }

